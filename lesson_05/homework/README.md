# Домашнее задание

## Шифр Цезаря

Реализуем [шифр Цезаря](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F) -- простой способ шифрования путем сдвига каждого символа на константу.

В файле **caesar.ex** определен модуль `Caesar`. Нужно реализовать функцию `encode/2`, которая принимает строку и сдвиг, и возвращает зашифрованную строку.

Пример:

```elixir
> Caesar.encode("Hello", 10)
"Rovvy"
> Caesar.encode('Hello', 5)
'Mjqqt'
```

Также нужно реализовать функцию `decode/2`, которая принимает зашифрованную строку и сдвиг, и возвращает оригинальную строку.

Пример:

```elixir
> Caesar.decode("Rovvy", 10)
"Hello"
> Caesar.decode('Mjqqt', 5)
'Hello'
```

Обе функции должны принимать строки и в двойных, и в одиночных кавычках.


## Шифр Цезаря с закольцованным сдвигом

Первый вариант шифрования не учитывает, что сдвиг может уйти за пределы валидного диапазона символов. Это не так заметно для Unicode, где валидный диапазон велик (но всё равно не бесконечен). Но для маленького алфавита это сразу будет заметно. Поэтому сдвиг нужно сделать закольцованным. Например, для алфавита A-Z сдвиг от буквы X на 5 символов проходит через Y, Z, A, B и попадает на C.

В нашей реализации мы ограничим валидный диапазон набором ASCII-кодов от 32 до 126.

Реализовать функцию `encode_ascii/2`, которая принимает строку и сдвиг, и возвращает зашифрованную строку.

Пример:

```elixir
> Caesar.encode_ascii('hello world', 15)
'wt{{~/\'~\"{s'
```

Реализовать функцию `decode_ascii/2`, которая принимает зашифрованную строку и сдвиг, и возвращает оригинальную строку.

Пример:

```elixir
> Caesar.decode_ascii('wt{{~/\'~\"{s', 15)
hello world'
```

Входящая строка должна состоять из символов в валидном диапазоне. Иначе обе функции генерируют исключение:

```elixir
raise "invalid ascii str"
```

Обе функции должны принимать строки и в двойных, и в одиночных кавычках.


## Trim (задача со звездочкой)

В файле **trim.ex** определён модуль `Trim`. Там есть готовая реализация функции `trim/1`, которая удаляет пробелы в начале и в конце строки. Однако, эта реализация не очень эффективна, она делает 4 прохода по строке.

Нужно реализовать функцию `effective_trim/1`, которая делает то же самое каким-нибудь более эффективным способом.


## Уплощение списка (задача со звездочкой)

В стандарной библиотеке есть функция `List.flatten/1`, которая принимает список, имеющий вложенные списки, и делает его плоским.

Пример:

```elixir
> List.flatten([1, [2, 3], 4, [5, [6, 7, [8, 9, 10]]]])
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Нужно сделать свою реализацию такой же функции. Это довольно просто сделать с оператором `++`, см **my_list.ex**. Но придти к более эффективному решению не так просто.

